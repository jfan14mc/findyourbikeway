<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Find Your Bikeway</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css">
    <style>
        body, html { 
            margin: 0; 
            padding: 0; 
            height: 100%; 
            font-family: Arial, sans-serif; 
            touch-action: manipulation; /* Prevent double-tap zoom */
        }
        #map { 
            width: 100%; 
            height: calc(100vh - 300px); 
        }
        #routing-container {
            display: flex;
            flex-direction: column;
            padding: 15px;
            background-color: #f0f0f0;
            gap: 10px;
        }
        #routing-container input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        #button-container {
            display: flex;
            gap: 10px;
        }
        #navigation-btn, #route-btn {
            flex-grow: 1;
            padding: 12px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #route-btn {
            background-color: #4CAF50;
            color: white;
        }
        #navigation-btn {
            background-color: #2196F3;
            color: white;
        }
        #avoidance-areas {
            margin-top: 10px;
            padding: 10px;
            background-color: #e0e0e0;
            text-align: center;
            font-size: 14px;
        }
        #error-display {
            color: red;
            padding: 10px;
            background-color: #ffeeee;
            text-align: center;
        }
        #route-instructions {
            background-color: #f9f9f9;
            padding: 10px;
            border-top: 1px solid #ddd;
        }
        .instruction {
            margin-bottom: 5px;
            padding: 5px;
            background-color: #f0f0f0;
        }
        #debug-info {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 1000;
            max-width: 300px;
            word-wrap: break-word;
            font-size: 12px;
        }

        /* Disable callout and highlight on mobile */
        * {
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
    </style>
</head>
<body>
    <div id="routing-container">
        <input type="text" id="start-input" placeholder="Start Location" value="8300 Baltimore Ave">
        <input type="text" id="end-input" placeholder="Destination" value="Bladensburg Waterfront Park">
        <div id="button-container">
            <button id="route-btn" onclick="calculateRoute()">Find Route</button>
            <button id="navigation-btn" onclick="toggleNavigationMode()">Л Navigation</button>
        </div>
    </div>
    <div id="avoidance-areas">
        Tap and hold twice to create avoidance areas
    </div>
    <div id="error-display"></div>
    <div id="map"></div>
    <div id="debug-info"></div>
    <div id="route-instructions"></div>

    <script src="https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js"></script>
    <script>
        // OpenRouteService API key (replace with your own)
        const ORS_API_KEY = '5b3ce3597851110001cf6248dbbdc789398f41cfa1403cf2b18e5bdf';

        // Global variables for tracking
        let currentRoute = null;
        let getPositionId = null;
        let navigationMode = false;
        let heading = null
        let radHeading = null
        let latitude = null
        let longitude = null
        let userCoords = null

        const isIOS = (
            navigator.userAgent.match(/(iPod|iPhone|iPad)/) &&
            navigator.userAgent.match(/AppleWebKit/)
        );

        // Error display function
        function displayError(message) {
            const errorDisplay = document.getElementById('error-display');
            errorDisplay.textContent = message;
            console.error(message);
        }

        // Clear previous errors
        function clearErrors() {
            const errorDisplay = document.getElementById('error-display');
            errorDisplay.textContent = '';
        }

        function updateDebugInfo(lon, lat) {
            const debugInfoElement = document.getElementById('debug-info');
            
            if (debugInfoElement) {
                debugInfoElement.innerHTML = `
                    <strong>Debug Information V13:</strong><br>
                    isIOS: ${isIOS}<br>
                    Current Location: ${latitude ? latitude.toFixed(7) : 'N/A'}, ${longitude ? longitude.toFixed(7) : 'N/A'}<br>
                    Current Heading: ${heading || 'N/A'}<br>
                    Navigation Mode: ${navigationMode}<br>
                `;
            }
        }

        // Initialize map
        const map = new ol.Map({
            target: 'map',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.OSM()
                })
            ],
            view: new ol.View({
                center: ol.proj.fromLonLat([-76.94260941249034, 38.98597311823279]), // McKeldin Mall
                zoom: 14,
                rotation: 0
            })
        });

        // Create vector layers for routes, avoidance areas, and user location
        const routeSource = new ol.source.Vector();
        const routeLayer = new ol.layer.Vector({
            source: routeSource,
            style: new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: 'blue',
                    width: 5
                })
            })
        });

        const avoidanceSource = new ol.source.Vector();
        const avoidanceLayer = new ol.layer.Vector({
            source: avoidanceSource,
            style: new ol.style.Style({
                fill: new ol.style.Fill({
                    color: 'rgba(255, 0, 0, 0.3)'
                }),
                stroke: new ol.style.Stroke({
                    color: 'red',
                    width: 2
                })
            })
        });

        // Create user location layer
        const userLocationSource = new ol.source.Vector();
        const userLocationLayer = new ol.layer.Vector({
            source: userLocationSource,
            style: new ol.style.Style({
                image: new ol.style.Circle({
                    radius: 12,
                    fill: new ol.style.Fill({color: 'blue'}),
                    stroke: new ol.style.Stroke({color: 'white', width: 3})
                })
            })
        });

        map.addLayer(routeLayer);
        map.addLayer(avoidanceLayer);
        map.addLayer(userLocationLayer);

        // Avoidance area creation variables
        let avoidanceCenter = null;
        let avoidanceCenterTimeout = null;
        let avoidanceDrawing = false;

        map.on('click', (event) => {
            // Reintroduce control-click check for desktop
            const isCtrlClick = event.originalEvent.ctrlKey;
            const isMobileTouch = event.type === 'touchstart'; // Add mobile touch detection

            // Only proceed if it's a ctrl-click or mobile touch
            if (!isCtrlClick && !isMobileTouch) return;

            // Rest of the existing avoidance area creation logic
            const feature = map.forEachFeatureAtPixel(event.pixel, 
                (feature, layer) => feature,
                { layerFilter: () => true }
            );

            // Remove feature logic remains the same
            if (feature && feature.getGeometry() instanceof ol.geom.Circle) {
                avoidanceSource.removeFeature(feature);
                return;
            }
            

            // Mobile avoidance area creation logic
            const coordinate = event.coordinate;
            
            // Clear any existing timeout
            if (avoidanceCenterTimeout) {
                clearTimeout(avoidanceCenterTimeout);
                avoidanceCenterTimeout = null;
            }

            if (!avoidanceCenter) {
                // First tap: set potential center and start a timeout
                avoidanceCenter = coordinate;
                avoidanceCenterTimeout = setTimeout(() => {
                    avoidanceDrawing = true;
                }, 500); // 500ms hold to confirm center
            } else {
                // Second tap: complete avoidance area if drawing is active
                if (avoidanceDrawing) {
                    const resolution = map.getView().getResolution();
                    const radius = Math.sqrt(
                        Math.pow(coordinate[0] - avoidanceCenter[0], 2) +
                        Math.pow(coordinate[1] - avoidanceCenter[1], 2)
                    );

                    // Create circle feature
                    const circle = new ol.Feature(
                        new ol.geom.Circle(avoidanceCenter, radius)
                    );
                    avoidanceSource.addFeature(circle);

                    // Reset drawing state
                    avoidanceCenter = null;
                    avoidanceDrawing = false;
                    avoidanceCenterTimeout = null;
                } else {
                    // If not drawing, reset center
                    avoidanceCenter = coordinate;
                    avoidanceCenterTimeout = setTimeout(() => {
                        avoidanceDrawing = true;
                    }, 500);
                }
            }
        });

        // Add touch event handlers for mobile compatibility
        map.getViewport().addEventListener('touchstart', (event) => {
            // Prevent default touch behavior to avoid scrolling/zooming
            event.preventDefault();
        });

        map.getViewport().addEventListener('touchend', (event) => {
            // Simulate click for touch devices
            if (event.touches.length === 0) {
                const pixel = map.getEventPixel(event.changedTouches[0]);
                map.forEachFeatureAtPixel(pixel, (feature) => {
                    // Optional: Add touch-specific feature interaction if needed
                });
            }
        });

        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth's radius in meters
            const 1 = lat1 * Math.PI / 180;
            const 2 = lat2 * Math.PI / 180;
            const  = (lat2 - lat1) * Math.PI / 180;
            const 位 = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(/2) * Math.sin(/2) +
                      Math.cos(1) * Math.cos(2) *
                      Math.sin(位/2) * Math.sin(位/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        function toggleNavigationMode() {
            const navigationBtn = document.getElementById('navigation-btn');
            navigationMode = !navigationMode;
            if (!navigationMode) {
                navigationBtn.textContent = 'Л Navigation';
                exitNavigation();
            } else {
                navigationBtn.textContent = 'Л Exit Navigation';
                startNavigation();
            }
            updateDebugInfo();
        }
        
        function startNavigation() {
            const navigationBtn = document.getElementById('navigation-btn');

            // Create center zoom interactions
            const centerZoom = new ol.interaction.MouseWheelZoom({ useAnchor: false });
            const centerPinchZoom = new ol.interaction.PinchZoom({ useAnchor: false });

            // Disable panning, rotation, and default zoom interactions
            const mapInteractions = map.getInteractions();
            mapInteractions.forEach(interaction => {
                if (interaction instanceof ol.interaction.DragPan || 
                    interaction instanceof ol.interaction.DragRotate || 
                    interaction instanceof ol.interaction.PinchRotate ||
                    interaction instanceof ol.interaction.DragZoom ||
                    interaction instanceof ol.interaction.MouseWheelZoom ||
                    interaction instanceof ol.interaction.PinchZoom) {
                    interaction.setActive(false);
                }
            });

            map.addInteraction(centerZoom);
            map.addInteraction(centerPinchZoom);

            if (isIOS) {
                DeviceOrientationEvent.requestPermission()
                .then((response) => {
                    if (response === "granted") {
                    window.addEventListener("deviceorientation", rotationHandler, true);
                    } else {
                    alert("Permission needs to be granted for navigation!");
                    }
                })
                .catch(() => alert("not supported"));

                DeviceMotionEvent.requestPermission()
                .then((response) => {
                    if (response === "granted") {
                    window.addEventListener("devicemotion", motionHandler, true);
                    } else {
                    alert("Permission needs to be granted for navigation!");
                    }
                })
                .catch(() => alert("not supported"));
            } else {
                window.addEventListener("deviceorientationabsolute", rotationHandler, true);
                window.addEventListener("devicemotion", motionHandler, true);
            }
            

            updateDebugInfo();
            map.getView().animate({
                    zoom: 16,
                    duration: 300
                });
        }
 
        function exitNavigation() {
            // Clear active watchers and position tracking
            if (getPositionId) {
                navigator.geolocation.clearWatch(getPositionId);
                getPositionId = null;
            }

            // Remove orientation event listeners
            window.removeEventListener("deviceorientation", handler, true);
            window.removeEventListener("deviceorientationabsolute", handler, true);
            window.removeEventListener("devicemotion", handler, true);

            // Restore all map interactions
            const mapInteractions = map.getInteractions();
            mapInteractions.forEach(interaction => {
                // Re-enable standard map interactions
                if (interaction instanceof ol.interaction.DragPan || 
                    interaction instanceof ol.interaction.DragRotate || 
                    interaction instanceof ol.interaction.PinchRotate ||
                    interaction instanceof ol.interaction.DragZoom ||
                    interaction instanceof ol.interaction.MouseWheelZoom ||
                    interaction instanceof ol.interaction.PinchZoom) {
                    interaction.setActive(true);
                }
            });

            // Reset map view to original state
            map.getView().setRotation(0);
            map.getView().setZoom(14);

            // Clear user location marker
            userLocationSource.clear();

            // Clear route instructions
            document.getElementById('route-instructions').innerHTML = '';

            // Zoom back to full route if exists
            if (currentRoute) {
                const routeFeature = new ol.Feature({
                    geometry: new ol.geom.LineString(
                        currentRoute.features[0].geometry.coordinates.map(
                            coord => ol.proj.fromLonLat(coord)
                        )
                    )
                });
                const extent = routeFeature.getGeometry().getExtent();
                map.getView().fit(extent, {
                    padding: [50, 50, 50, 50],
                    duration: 1000
                });
            }

            // Reset navigation mode button
            const navigationBtn = document.getElementById('navigation-btn');
            navigationBtn.textContent = 'Л Navigation';
        }

        function rotationHandler(event) {
            heading = event.webkitCompassHeading || Math.abs(event.alpha - 360);
            radHeading = -1 * heading * (Math.PI / 180);
            userCoords = uC;
            
            map.getView().animate({
                rotation: radHeading,
                duration: 150,
            });
            updateDebugInfo();
        }

        function motionHandler(event) {
            getPositionId = navigator.geolocation.getCurrentPosition(
                (position) => {
                    lon = position.coords.longitude;
                    lat = position.coords.latitude;
                    uC = ol.proj.fromLonLat([lon, lat]);
                    (error) => {
                        displayError(`Geolocation error: ${error.message}`);
                        toggleNavigationMode()
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 5000,
                        maximumAge: 0
                    }
                }
            )

            longitude = lon
            latitude = lat
            userCoords = uC;
            
            map.getView().animate({
                center: userCoords,
                duration: 150,
            });

            // Clear previous user marker
            userLocationSource.clear();

            // Create and add user location marker
            const userMarker = new ol.Feature({
                geometry: new ol.geom.Point(userCoords)
            });
            userLocationSource.addFeature(userMarker);
            updateDebugInfo();
        }

        // Modify displayRouteInstructions to support both preview and navigation modes
        function displayRouteInstructions() {
            if (!currentRoute || !currentRoute.features[0]) return;

            const instructionsContainer = document.getElementById('route-instructions');
            instructionsContainer.innerHTML = ''; // Clear previous instructions

            // Get all steps from the route
            const allSteps = currentRoute.features[0].properties.segments[0].steps;
            
            // Determine which instructions to show based on navigation mode
            const instructionsToShow = navigationMode 
                ? allSteps.slice(0, 2)  // Only next 3 in navigation mode
                : allSteps;  // All instructions in preview mode

            // Create and append instructions
            instructionsToShow.forEach((step, index) => {
                const div = document.createElement('div');
                div.classList.add('instruction');
                
                // Get direction symbol and format distance
                const distanceKm = (step.distance / 1000).toFixed(2);
                
                div.textContent = ` ${step.instruction} (${distanceKm} km)`;
                instructionsContainer.appendChild(div);
            });
        }

        async function calculateRoute() {
            // Clear previous errors and routes
            clearErrors();
            routeSource.clear();

            const startInput = document.getElementById('start-input').value;
            const endInput = document.getElementById('end-input').value;

            try {
                // Geocode start and end locations
                const startCoords = await geocode(startInput);
                const endCoords = await geocode(endInput);

                if (!startCoords || !endCoords) {
                    displayError('Could not find one or both locations');
                    return;
                }

                // Prepare avoidance polygons (existing code)
                const avoidanceAreas = avoidanceSource.getFeatures().map(feature => {
                    const geometry = feature.getGeometry();
                    const center = ol.proj.toLonLat(geometry.getCenter());
                    const radius = geometry.getRadius() / 1000;
                    
                    return [createCirclePolygon(center, radius)]
                });

                // Prepare request to OpenRouteService
                const routeRequest = {
                    "coordinates": [[startCoords[0], startCoords[1]], [endCoords[0], endCoords[1]]],
                    "options": {
                        "avoid_polygons": {
                            "type": "MultiPolygon",
                            "coordinates": avoidanceAreas
                        }  
                    },
                    "instructions": true // Request detailed instructions
                };

                // Fetch route from OpenRouteService
                const response = await fetch('https://api.openrouteservice.org/v2/directions/cycling-regular/geojson', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': ORS_API_KEY
                    },
                    body: JSON.stringify(routeRequest)
                });

                // Check if response is ok
                if (!response.ok) {
                    const errorBody = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, body: ${errorBody}`);
                }

                // Store route globally
                currentRoute = await response.json();

                // Create route feature
                const routeFeature = new ol.Feature({
                    geometry: new ol.geom.LineString(
                        currentRoute.features[0].geometry.coordinates.map(
                            coord => ol.proj.fromLonLat(coord)
                        )
                    )
                });

                // Add route to vector source
                routeSource.addFeature(routeFeature);

                // Zoom to route
                const extent = routeFeature.getGeometry().getExtent();
                map.getView().fit(extent, {
                    padding: [50, 50, 50, 50],
                    duration: 1000
                });

                // Display route instructions
                displayRouteInstructions();

                // Prepare navigation button
                const navigationBtn = document.getElementById('navigation-btn');

            } catch (error) {
                displayError(`Route calculation error: ${error.message}`);
            }
        }

        async function geocode(query) {
            const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`);
            const data = await response.json();
            return data.length > 0 
                ? [parseFloat(data[0].lon), parseFloat(data[0].lat)]
                : null;
        }

        // Helper function to create a circular polygon for avoidance areas
        function createCirclePolygon(center, radiusKm) {
            const polygon = [];

            // Number of points to approximate the circle
            const numPoints = 36;

            for (let i = 0; i <= numPoints; i++) {
                const bearing = (i * 360) / numPoints;
                const point = destinationPoint(center[1], center[0], radiusKm, bearing);
                polygon.push(point);
            }

            // Close the polygon by repeating the first point
            polygon.push(polygon[0]);

            return polygon;
        }

        // Helper function to calculate destination point given distance and bearing
        function destinationPoint(lat, lon, distance, bearing) {
            const earthRadius = 6371; // kilometers
            const 未 = distance / earthRadius;
            const 胃 = bearing * Math.PI / 180;

            const 1 = lat * Math.PI / 180;
            const 位1 = lon * Math.PI / 180;

            const 2 = Math.asin(Math.sin(1) * Math.cos(未) + 
                      Math.cos(1) * Math.sin(未) * Math.cos(胃));
            
            const 位2 = 位1 + Math.atan2(Math.sin(胃) * Math.sin(未) * Math.cos(1),
                      Math.cos(未) - Math.sin(1) * Math.sin(2));

            return [
                (位2 * 180 / Math.PI + 540) % 360 - 180, // normalize longitude
                2 * 180 / Math.PI
            ];
        }
        
        document.addEventListener('DOMContentLoaded', updateDebugInfo);
    </script>
</body>
</html>